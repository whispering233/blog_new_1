{"meta":{"title":"whispering233'world","subtitle":"","description":"learning in using","author":"whispering233","url":"http://example.com","root":"/"},"pages":[{"title":"所有分类","date":"2023-05-28T14:56:42.992Z","updated":"2023-05-28T10:12:54.971Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-05-28T14:56:42.936Z","updated":"2023-05-28T10:12:54.975Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"archives","date":"2022-08-02T07:03:52.000Z","updated":"2023-05-28T10:12:10.607Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"","date":"2023-05-28T14:56:42.944Z","updated":"2023-05-28T10:12:54.971Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"你来到了知识的荒芜之地"}],"posts":[{"title":"持续集成测试","slug":"持续集成测试","date":"2023-05-28T10:17:28.000Z","updated":"2023-05-28T10:17:28.903Z","comments":true,"path":"2023/05/28/持续集成测试/","link":"","permalink":"http://example.com/2023/05/28/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"《社会各阶级的分析》笔记","slug":"社会各阶级的分析","date":"2022-08-03T16:17:39.000Z","updated":"2023-05-28T10:12:54.970Z","comments":true,"path":"2022/08/04/社会各阶级的分析/","link":"","permalink":"http://example.com/2022/08/04/%E7%A4%BE%E4%BC%9A%E5%90%84%E9%98%B6%E7%BA%A7%E7%9A%84%E5%88%86%E6%9E%90/","excerpt":"","text":"写作背景及目的党内两种倾向1923年2月7日，北洋政府直系军阀吴佩孚镇压京汉铁路工人大罢工，史称二七惨案。 二七惨案使共产党认识到中国的反动势力力量太大，民族民主革命仅仅依靠工人阶级的孤军奋斗是不够的，应该争取一切可能的同盟者。 同样，孙中山在几经挫折之后，认为中国革命要做出改变，需要团结更多的力量，积极欢迎共产党员的合作。 只注意工人运动1923年6月12日至20日，中共三大召开。毛泽东被选入中央执行委员会，这是毛泽东第一次进入中央领导核心，时年三十岁。 在中共三大上，毛泽东开始注意到当时党内的重要领导人张国焘只重视工人运动，不注意团结国民党内的革命力量、忽视农民的力量。 当时共产党内反对国共合作的人不在少数，并没有认识到当前国内革命的首要目标在于反帝反封建、国民党内部存在可以团结的革命力量。 “我党党员如若加入国民党，势必会引起许多复杂而不易解决的问题，其结果将有害于革命势力的团结。” – 张国焘 中共三大 过分重视国共合作而陈独秀与此相反，过于注重跟国民党合作，处处让步、妥协，放弃无产阶级革命领导权。同样地忽视农民潜藏的巨大力量，甚至抵制农民运动，严重地影响了农民运动的发展。 “我今天认为，如果当时比较彻底地把农民运动组织起来，把农民武装起来，开展反对地主的阶级斗争，那么，苏维埃就会在全国范围早一些并且有力得多地发展起来。” – 毛泽东 国民党内部分化1924年1月至12月，毛泽东在国民党内工作了近一年时间。 1月，毛泽东作为湖南代表参加了在广州召开的中国国民党第一次全国代表大会。1月31日，毛泽东被派往上海执行部工作。 当时，实际负责上海执行部的是组织部部长胡汉民，毛泽东任胡汉民的秘书，职责是“协助部长，办理本部事务”。 胡汉民是国民党元老，孙中山对他格外倚重，国民党改组后的许多重大事情，都离不开胡汉民的参与。因此，组织部的实际工作也就落到了毛泽东的肩上。 但随着胡汉民的调离，毛泽东开始被一些分共、反共势力所排挤。毛泽东认识到国民党内部存在分化的两派。 国民党左派，支持革命，主张“联共”；国民党右派，反对革命，暗地里策划“反共”行动。 7月，毛泽东不得不辞去组织部秘书职务。 12月，由于工作困难重重、劳累成疾，毛泽东请假回到湖南老家韶山。 韶山养病毛泽东在老家养病期间，并未闲着，而是利用这段时间组织起农民运动。 毛泽东利用当地原有族校，创办了20多所农民夜校。夜校教农民识字、打算盘，并讲授三民主义和马克思主义。 农民阶级觉悟提高以后，毛泽东领导了“平粜阻运”运动。 平粜阻运1924年，韶山水灾；1925年又遇旱灾，几乎绝收。 但各地的地主豪绅一直把持着粮食粜卖价格。农民辛勤劳作一年，即使风调雨顺，稻谷大丰收，在极低的粮食收购价前也卖不了几个钱；等农民卖粮交了租子钱，手头的余钱根本买不了几斤价格高的惊人的白米，一家人只有靠红薯、芋头等粗粮度日，更不要说欠收之年。大地主陈述生、汤峻岩却在此时借机哄抬米价，并且将米运到外地售卖牟取暴利。 有了觉悟的农民，被毛泽东组织了起来，成立了农民协会。农民协会成员们拿着梭镖、长矛，开始在乡间值班设卡。只要没有农会的批条，所有外运粮食的船只车辆一律被拦了下来。在农会的坚决斗争下，地主们暂时妥协，不得不平价销售粮食。 可以说，平粜阻运为后来的湖南农民运动打下了基础。 “那年冬天我回到湖南休养——我在上海生病，但在湖南期间，我组织了该省伟大的农民运动的核心。” – 毛泽东 文章写作在当时，共产党内的两种倾向都没有意识到农民中潜藏的巨大力量、同时也没有警惕国产党内部“反革命”、“反共”的右派，大革命潜藏着失败的危险因素。 1925年3月12日，孙中山先生在北京逝世； 1925年5月30日，五卅运动。 1925年6月6日，上海及青岛日资纱厂工人罢工遭到帝国主义及其走狗的血腥镇压。 1925年6月19日，广东、香港工人为声援上海五卅惨案举行大罢工。 1925年6月23日，在广州英国海军陆战队向游行的中国老百姓开枪、开炮，打死59名中国人，重伤者百余人，造成沙基惨案。 1925年8月11日，天津裕大工会向厂方提出正当要求，遭中日军警血腥镇压。 1925年8月20日，国民党右派在广州暗杀了国民党左派领袖廖仲恺。 1925年11月23日，国民党右派召开西山会议，开除李大钊、毛泽东等人国民党党籍。 1925年秋，毛泽东呕心沥血，在昏暗的油灯下写下了《中国社会各阶级的分析》这篇重要文章。 文章内容及影响《中国社会各阶级的分析》一针见血地指出革命的首要问题。 “谁是我们的敌人，谁是我们的朋友？这个问题是革命的首要问题。中国过去一切革命斗争成效甚少，其基本原因就是因为不能团结真正的朋友，以攻击真正的敌人。” 我们要分辨真正的敌友，不可不将中国社会各阶级的经济地位及其对于革命的态度，作一个大概的分析。 这篇文章的完成依靠的是毛泽东对革命情况的反思、对多年工作见闻的总结以及农民运动的组织实践，是对当时中国社会各阶级的综合考察，深刻地指出了革命的朋友和敌人，是毛泽东思想的萌芽。 ”革命不是请客吃饭，不是做文章，不是绘画绣花，不能那样雅致，那样从容不迫，文质彬彬，那样温良恭俭让。革命是暴动，是一个阶级推翻一个阶级的暴烈的行动“，一切想当然的假设与幻想都会被现实无情地粉碎。 只会坐在椅子上读书看报、喝茶听曲的人是写不出来这种文章的。 文章发表《中国社会各阶级的分析》一文在刚问世之时并不被党内高层看好，陈独秀拒绝该文在党的机关刊物上发表。 1939年，毛泽东在与美国记者斯诺谈话时，回忆起这段经历。 ”我那时文章写得越来越多，在共产党内，我特别负责农民工作。根据我的研究和我组织湖南农民的经验，我写了两本小册子，一本是《中国社会各阶级的分析》，另一本是《赵恒惕的阶级基础和我们当前的任务》。陈独秀反对第一本小册子里表示的意见，这本小册子主张在共产党领导下实行激进的土地政策和大力组织农民。陈独秀拒绝在党中央机关报刊上发表它。” “大致在这个时候，我开始不同意陈独秀的右倾机会主义政策。我们逐渐地分道扬镳了。” 毛泽东把文章寄往别处。 1925年12月，国民革命军第二司令部政治部编辑的半月刊《革命》第四期刊登了《中国社会各阶级的分析》。文章一目了然地指出无产阶级的革命要依靠谁、团结谁以打击谁，引起了人们的普遍注意。 1926年2月，国民党农民部主办的全国性刊物《中国农民》全文转载《中国社会各阶级的分析》，该文的影响变得更大。 1926年3月，中国社会主义青年团的机关刊物《中国青年》致信毛泽东，对文章提出修改意见，并决定发表修改后的文章。在《中国青年》上的发表，使得《中国社会各阶级的分析》声明远播，也正式奠定毛泽东在农民运动中的领袖地位。 1926年5月，毛泽东在广州主办农民运动讲习所。农讲所重印了《中国社会各阶级的分析》，发给学员作为课本使用。 之后，中国革命在《中国社会各阶级的分析》的指导下，少走了许多弯路。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"毛选","slug":"毛选","permalink":"http://example.com/tags/%E6%AF%9B%E9%80%89/"}]},{"title":"webpack简明教程","slug":"webpack简明教程","date":"2022-08-03T16:17:39.000Z","updated":"2023-05-28T10:12:54.970Z","comments":true,"path":"2022/08/04/webpack简明教程/","link":"","permalink":"http://example.com/2022/08/04/webpack%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/","excerpt":"","text":"介绍 webpack是一种静态资源打包工具 以一个文件或多个文件作为打包的入口，将整个项目所有文件编译组合成一个或多个文件输出 输出文件叫做 bundle 本身功能有限，需要额外的加载器和插件增强功能 开发模式 Development：仅能编译 JS 中的 ES Module 语法 生产模式 Production：能编译 JS 中的 ES Module 语法，还能压缩 JS 代码 前置环境起步 初始化 来到项目根目录 npm init -y 生成package.json 1234567891011121314&#123; // name != webpack &quot;name&quot;: &quot;webpack_template&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, // 执行脚本 npm run xxx &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 构建文件 12345- / - src - js - helloworld.js main.js 1234// helloworld.jsexport default function hello() &#123; console.log(&quot;hello world&quot;)&#125; 123// main.jsimport hello from &quot;./js/helloworld&quot;;hello() 下载依赖 npm i webpack webpack-cli - D 生产环境使用 启用 npx webpack ./src/main.js --mode=development npx webpack 运行webpack包 ./src/main.js 指定入口文件，从此文件开始打包 --mode=development 指定打包模式 development production 代码压缩，取消注释 123- / - dist - main.js #打包结果 1(()=&gt;&#123;&quot;use strict&quot;;console.log(&quot;hello world&quot;)&#125;)(); 配置文件5大核心概念 entry output loader plugins mode development production 处理资源Webpack 官方 Loader 文档 修改输出资源名称及路径12345678910111213141516171819202122232425262728output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), // 将 js 文件输出到 static/js 目录中, filename: &quot;static/js/main.js&quot;, clean: true, // 自动将上次打包目录资源清空 &#125;module: &#123; rules: [ &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125; ]&#125; html npm i html-webpack-plugin -D 12345678910111213const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;src&quot;), &#125;), new HtmlWebpackPlugin(&#123; // 以 public/index.html 为模板创建文件 // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源 template: path.resolve(__dirname, &quot;public/index.html&quot;), &#125;), ] CSS CSS npm i css-loader style-loader -D css-loader：负责将 CSS 文件编译成 Webpack 能识别的模块 style-loader：会动态创建一个 Style 标签，里面放置 Webpack 中 CSS 模块内容 Less npm i less-loader -D 负责将 Less 文件编译成 CSS 文件 Sass and Scss npm i sass-loader sass -D sass-loader：负责将 Sass 文件编译成 CSS 文件 sass：sass-loader 依赖 sass 进行编译 Styl npm i stylus-loader -D stylus-loader：负责将 Styl 文件编译成 CSS 文件 提取CSS成单独的文件 npm i mini-css-extract-plugin -D const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;); &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;], &#125;, plugins: [ // 提取css成单独文件 new MiniCssExtractPlugin(&#123; // 定义输出文件名和目录 filename: &quot;static/css/main.css&quot;, &#125;), ], 12345678910111213141516171819202122232425##### CSS兼容性处理1. `npm i postcss-loader postcss postcss-preset-env -D`2. ```javascript &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [ MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &#123; loader: &quot;postcss-loader&quot;, options: &#123; postcssOptions: &#123; plugins: [ &quot;postcss-preset-env&quot;, // 能解决大多数样式兼容性问题 ], &#125;, &#125;, &#125;, ], &#125;, 控制兼容性 12345// package.json&#123; // 交集 &quot;browserslist&quot;: [&quot;last 2 version&quot;, &quot;&gt; 1%&quot;, &quot;not dead&quot;]&#125; 代码复用123456789101112131415161718// 获取处理样式的Loadersconst getStyleLoaders = (preProcessor) =&gt; &#123; return [ MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &#123; loader: &quot;postcss-loader&quot;, options: &#123; postcssOptions: &#123; plugins: [ &quot;postcss-preset-env&quot;, // 能解决大多数样式兼容性问题 ], &#125;, &#125;, &#125;, preProcessor, ].filter(Boolean);&#125;; CSS压缩 npm i css-minimizer-webpack-plugin -D 1234plugins: [ // css压缩 new CssMinimizerPlugin(), ], jsEslint 可组装的 JavaScript 和 JSX 语法检查工具 配置文件 .eslintrc.*：新建文件，位于项目根目录 .eslintrc .eslintrc.js .eslintrc.json 区别在于配置格式不一样 package.json 中 eslintConfig：不需要创建文件，在原有文件基础上写 ESLint 会查找和自动读取它们，所以以上配置文件只需要存在一个即可 1234567891011// .eslintrc.jsmodule.exports = &#123; // 解析选项 parserOptions: &#123;&#125;, // 具体检查规则 rules: &#123;&#125;, // 继承其他规则 extends: [], // ... // 其他规则详见：https://eslint.bootcss.com/docs/user-guide/configuring&#125;; 1234567parserOptions: &#123; ecmaVersion: 6, // ES 语法版本 sourceType: &quot;module&quot;, // ES 模块化 ecmaFeatures: &#123; // ES 其他特性 jsx: true // 如果是 React 项目，就需要开启 jsx 语法 &#125;&#125; 1234567891011121314rules: &#123; // &quot;off&quot;, &quot;warn&quot;, &quot;error&quot; // &quot;error&quot; (当被触发的时候，程序会退出) semi: &quot;error&quot;, // 禁止使用分号 &#x27;array-callback-return&#x27;: &#x27;warn&#x27;, // 强制数组方法的回调函数中有 return 语句，否则警告 &#x27;default-case&#x27;: [ &#x27;warn&#x27;, // 要求 switch 语句中有 default 分支，否则警告 &#123; commentPattern: &#x27;^no default$&#x27; &#125; // 允许在最后注释 no default, 就不会有警告了 ], eqeqeq: [ &#x27;warn&#x27;, // 强制使用 === 和 !==，否则警告 &#x27;smart&#x27; // https://eslint.bootcss.com/docs/rules/eqeqeq#smart 除了少数情况下不会有警告 ],&#125; 1234567891011- [Eslint 官方的规则](https://eslint.bootcss.com/docs/rules/)：`eslint:recommended`- [Vue Cli 官方的规则](https://github.com/vuejs/vue-cli/tree/dev/packages/@vue/cli-plugin-eslint)：`plugin:vue/essential`- [React Cli 官方的规则](https://github.com/facebook/create-react-app/tree/main/packages/eslint-config-react-app)：`react-appmodule.exports = &#123; extends: [&quot;eslint:recommended&quot;], rules: &#123; // 我们的规则会覆盖掉extends的规则 eqeqeq: [&quot;warn&quot;, &quot;smart&quot;], &#125;,&#125;; npm i eslint-webpack-plugin eslint -D 12345678910111213141516// .eslintrc.jsmodule.exports = &#123; // 继承 Eslint 规则 extends: [&quot;eslint:recommended&quot;], env: &#123; node: true, // 启用node中全局变量 browser: true, // 启用浏览器中全局变量 &#125;, parserOptions: &#123; ecmaVersion: 6, sourceType: &quot;module&quot;, &#125;, rules: &#123; &quot;no-var&quot;: 2, // 不能使用 var 定义变量 &#125;,&#125;; 12345678// webpack.config.jsconst ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;); plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;src&quot;), &#125;), ], BabelJavaScript 编译器。 主要用于将 ES6 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。 配置文件 babel.config.*：新建文件，位于项目根目录 babel.config.js babel.config.json .babelrc.*：新建文件，位于项目根目录 .babelrc .babelrc.js .babelrc.json package.json 中 babel：不需要创建文件，在原有文件基础上写 12345// babel.config.jsmodule.exports = &#123; // 预设 presets: [],&#125;; 简单理解：就是一组 Babel 插件, 扩展 Babel 功能 @babel/preset-env: 一个智能预设，允许您使用最新的 JavaScript。 @babel/preset-react：一个用来编译 React jsx 语法的预设 @babel/preset-typescript：一个用来编译 TypeScript 语法的预设 npm i babel-loader @babel/core @babel/preset-env -D 1234// babel.config.jsmodule.exports = &#123; presets: [&quot;@babel/preset-env&quot;],&#125;; 123456// webpack.config.js &#123; test: /\\.js$/, exclude: /node_modules/, // 排除node_modules代码不编译 loader: &quot;babel-loader&quot;, &#125;, otherswebpack 5 内置file-loader 和 url-loader 将小于某个大小的图片转化成 data URI 形式（Base64 格式） 减少请求数量，但图片资源体积变大 123456789&#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024 // 小于10kb的图片会被base64处理 &#125; &#125; &#125;, 1234567&#123; test: /\\.(ttf|woff2?|map4|map3|avi)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;,&#125;, type: &quot;asset/resource&quot; 相当于file-loader, 将文件转化成 Webpack 能识别的资源，其他不做处理 type: &quot;asset&quot; 相当于url-loader, 将文件转化成 Webpack 能识别的资源，同时小于某个大小的资源会处理成 data URI 形式 开发服务器 npm i webpack-dev-server -D 12345devServer: &#123; host: &quot;localhost&quot;, // 启动服务器域名 port: &quot;3000&quot;, // 启动服务器端口号 open: true, // 是否自动打开浏览器 &#125;, npx webpack serve 代码只会在内存中编译打包，不会输出到dist目录下 代码优化文件准备123456789101112├── webpack-template (项目根目录) ├── config (Webpack配置文件目录) │ ├── webpack.dev.js(开发模式配置文件) │ └── webpack.prod.js(生产模式配置文件) ├── node_modules (下载包存放目录) ├── src (项目源码目录，除了html其他都在src里面) │ └── 略 ├── public (项目html文件) │ └── index.html ├── .eslintrc.js(Eslint配置文件) ├── babel.config.js(Babel配置文件) └── package.json (包的依赖管理配置文件) 123456789// package.json&#123; // 其他省略 &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;npm run dev&quot;, &quot;dev&quot;: &quot;npx webpack serve --config ./config/webpack.dev.js&quot;, &quot;build&quot;: &quot;npx webpack --config ./config/webpack.prod.js&quot; &#125;&#125; webpack.dev.jswebpack.prod.js提升开发体验SourceMapWebpack DevTool 文档 SourceMap（源代码映射）是一个用来生成源代码与构建后代码一一映射的文件的方案。 它会生成一个 xxx.map 文件，里面包含源代码和构建后代码每一行、每一列的映射关系。当构建后代码出错了，会通过 xxx.map 文件，从构建后代码出错位置找到映射后源代码出错位置，从而让浏览器提示源代码文件出错位置，帮助我们更快的找到错误根源。 开发模式：cheap-module-source-map 优点：打包编译速度快，只包含行映射 缺点：没有列映射 12// webpack.dev.js devtool: &quot;cheap-module-source-map&quot;, 生产模式：source-map 优点：包含行&#x2F;列映射 缺点：打包编译速度更慢 &#x2F;&#x2F; webpack.prod.js devtool: “source-map”, 1234567891011121314151617### 提升打包构建速度#### HotModuleReplacementHotModuleReplacement（HMR/热模块替换）：在程序运行中，替换、添加或删除模块，而无需重新加载整个页面。```javascript// webpack.dev.jsdevServer: &#123; host: &quot;localhost&quot;, // 启动服务器域名 port: &quot;3000&quot;, // 启动服务器端口号 open: true, // 是否自动打开浏览器 hot: true, // 开启HMR功能（只能用于开发环境，生产环境不需要了） &#125;, js 处理判断是否支持，支持用模块替换 123456// 判断是否支持HMR功能if (module.hot) &#123; module.hot.accept(&quot;./js/example.js&quot;, function (example) &#123; const result = example(2, 1); console.log(result); &#125;); 要跟 vue-loader, react-hot-loader 结合使用，自动执行 One of打包时每个文件都会经过所有 loader 处理，虽然因为 test 正则原因实际没有处理上，但是都要过一遍。比较慢。 顾名思义就是只能匹配上一个 loader, 剩下的就不匹配了。 1234567rules: [ &#123; oneOf: [ ...... ] &#125; ] Include&#x2F;Exclude开发时我们需要使用第三方的库或插件，所有文件都下载到 node_modules 中了。而这些文件是不需要编译可以直接使用的。 所以我们在对 js 文件处理时，要排除 node_modules 下面的文件。 12345678&#123; test: /\\.js$/, // 排除node_modules代码不编译 // exclude: /node_modules/, // 两个只能同时用一个 include: path.resolve(__dirname, &quot;../src&quot;), // 也可以用包含 loader: &quot;babel-loader&quot;, &#125;, Cache每次打包时 js 文件都要经过 Eslint 检查 和 Babel 编译，速度比较慢。 我们可以缓存之前的 Eslint 检查 和 Babel 编译结果，这样第二次打包时速度就会更快了。 对 Eslint 检查 和 Babel 编译结果进行缓存。 12345678910111213141516171819202122&#123; test: /\\.js$/, // 排除node_modules代码不编译 // exclude: /node_modules/, // 两个只能同时用一个 include: path.resolve(__dirname, &quot;../src&quot;), // 也可以用包含 loader: &quot;babel-loader&quot;, options: &#123; cacheDirectory: true, // 开启babel编译缓存 cacheCompression: false, // 缓存文件不要压缩 &#125;, &#125;, plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;../src&quot;), cache: true, // 开启缓存 // 缓存目录 cacheLocation: path.resolve(__dirname, &quot;../node_modules/.cache/.eslintcache&quot;) &#125;), ] Thread当项目越来越庞大时，打包速度越来越慢，甚至于需要一个下午才能打包出来代码。这个速度是比较慢的。 我们想要继续提升打包速度，其实就是要提升 js 的打包速度，因为其他文件都比较少。 而对 js 文件处理主要就是 eslint 、babel、Terser 三个工具，所以我们要提升它们的运行速度。 我们可以开启多进程同时处理 js 文件，这样速度就比之前的单进程打包更快了。 多进程打包：开启电脑的多个进程同时干一件事，速度更快。 需要注意：请仅在特别耗时的操作中使用，因为每个进程启动就有大约为 600ms 左右开销。 npm i thread-loader -D 123456789101112131415161718192021222324252627282930313233343536373839// webpack.config.jsconst os = require(&quot;os&quot;);const TerserPlugin = require(&quot;terser-webpack-plugin&quot;);// cpu核数const threads = os.cpus().length;&#123; test: /\\.js$/, include: path.resolve(__dirname, &quot;../src&quot;), use: [ &#123; loader: &quot;thread-loader&quot;, // 开启多进程 options: &#123; workers: threads, // 数量 &#125;, &#125;, &#123; loader: &quot;babel-loader&quot;, options: &#123; cacheDirectory: true, // 开启babel编译缓存 &#125;, &#125;, ], &#125;,// 插件 plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;../src&quot;), cache: true, // 开启缓存 // 缓存目录 cacheLocation: path.resolve(__dirname, &quot;../node_modules/.cache/.eslintcache&quot;), threads, // 开启多进程 &#125;), new TerserPlugin(&#123; parallel: threads, &#125;) ], 减少代码体积Tree Shaking开发时我们定义了一些工具函数库，或者引用第三方工具函数库或组件库。 如果没有特殊处理的话我们打包时会引入整个库，但是实际上可能我们可能只用上极小部分的功能。 这样将整个库都打包进来，体积就太大了 Tree Shaking 是一个术语，通常用于描述移除 JavaScript 中的没有使用上的代码。 注意：它依赖 ES Module。 Webpack 已经默认开启了这个功能，无需其他配置。 Babel 辅助代码Babel 为编译的每个文件都插入了辅助代码，使代码体积过大！ Babel 对一些公共方法使用了非常小的辅助代码，比如 _extend。默认情况下会被添加到每一个需要它的文件中。 你可以将这些辅助代码作为一个独立模块，来避免重复引入。 @babel/plugin-transform-runtime: 禁用了 Babel 自动对每个文件的 runtime 注入，而是引入 @babel/plugin-transform-runtime 并且使所有辅助代码从这里引用。 npm i @babel/plugin-transform-runtime -D 12345678910111213141516171819202122232425&#123; test: /\\.js$/, // 排除node_modules代码不编译 // exclude: /node_modules/, // 两个只能同时用一个 include: path.resolve(__dirname, &quot;../src&quot;), // 也可以用包含 use: [ &#123; loader: &quot;thread-loader&quot;, // 开启多进程 options: &#123; workers: threads, // 数量 &#125;, &#125;, &#123; loader: &quot;babel-loader&quot;, options: &#123; cacheDirectory: true, // 开启babel编译缓存 cacheCompression: false, // 缓存文件不要压缩 plugins: [ &quot;@babel/plugin-transform-runtime&quot; // 减少代码体积 ] &#125;, &#125; ] &#125;, Image Minimizer开发如果项目中引用了较多图片，那么图片体积会比较大，将来请求速度比较慢。 我们可以对图片进行压缩，减少图片体积。 注意：如果项目中图片都是在线链接，那么就不需要了。本地项目静态图片才需要进行压缩。 npm i image-minimizer-webpack-plugin imagemin -D 无损 npm install imagemin-gifsicle imagemin-jpegtran imagemin-optipng imagemin-svgo -D 有损 npm install imagemin-gifsicle imagemin-mozjpeg imagemin-pngquant imagemin-svgo -D 无损 12345678910111213141516171819202122232425262728293031// webpack.config.jsconst ImageMinimizerPlugin = require(&quot;image-minimizer-webpack-plugin&quot;);// 压缩图片 new ImageMinimizerPlugin(&#123; minimizer: &#123; implementation: ImageMinimizerPlugin.imageminGenerate, options: &#123; plugins: [ [&quot;gifsicle&quot;, &#123; interlaced: true &#125;], [&quot;jpegtran&quot;, &#123; progressive: true &#125;], [&quot;optipng&quot;, &#123; optimizationLevel: 5 &#125;], [ &quot;svgo&quot;, &#123; plugins: [ &quot;preset-default&quot;, &quot;prefixIds&quot;, &#123; name: &quot;sortAttrs&quot;, params: &#123; xmlnsOrder: &quot;alphabetical&quot;, &#125;, &#125;, ], &#125;, ], ], &#125;, &#125;, &#125;), 打包时会出现报错： 12Error: Error with &#x27;src\\images\\1.jpeg&#x27;: &#x27;&quot;C:\\Users\\86176\\Desktop\\webpack\\webpack_code\\node_modules\\jpegtran-bin\\vendor\\jpegtran.exe&quot;&#x27;Error with &#x27;src\\images\\3.gif&#x27;: spawn C:\\Users\\86176\\Desktop\\webpack\\webpack_code\\node_modules\\optipng-bin\\vendor\\optipng.exe ENOENT 我们需要安装两个文件到 node_modules 中才能解决, 文件可以从课件中找到： jpegtran.exe 需要复制到 node_modules\\jpegtran-bin\\vendor 下面 jpegtran 官网地址 optipng.exe 需要复制到 node_modules\\optipng-bin\\vendor 下面 OptiPNG 官网地址 优化代码运行性能Code Split打包代码时会将所有 js 文件打包到一个文件中，体积太大了。我们如果只要渲染首页，就应该只加载首页的 js 文件，其他文件不应该加载。 所以我们需要将打包生成的文件进行代码分割，生成多个 js 文件，渲染哪个页面就只加载某个 js 文件，这样加载的资源就少，速度就更快。 代码分割（Code Split）主要做了两件事： 分割文件：将打包生成的文件进行分割，生成多个 js 文件。 按需加载：需要哪个文件就加载哪个文件。 多入口npm i webpack webpack-cli html-webpack-plugin -D 1234567891011121314151617// webpack.config.js// 多入口 entry: &#123; main: &quot;./src/main.js&quot;, app: &quot;./src/app.js&quot;, &#125;, output: &#123; path: path.resolve(__dirname, &quot;./dist&quot;), // [name]是webpack命名规则，使用chunk的name作为输出的文件名。 // 什么是chunk？打包的资源就是chunk，输出出去叫bundle。 // chunk的name是啥呢？ 比如： entry中xxx: &quot;./src/xxx.js&quot;, name就是xxx。注意是前面的xxx，和文件名无关。 // 为什么需要这样命名呢？如果还是之前写法main.js，那么打包生成两个js文件都会叫做main.js会发生覆盖。(实际上会直接报错的) filename: &quot;js/[name].js&quot;, clear: true, &#125; 提取重复代码12345678910111213141516171819202122232425262728293031323334353637383940optimization: &#123; // 代码分割配置 splitChunks: &#123; chunks: &quot;all&quot;, // 对所有模块都进行分割 // 以下是默认值 // minSize: 20000, // 分割代码最小的大小 // minRemainingSize: 0, // 类似于minSize，最后确保提取的文件大小不能为0 // minChunks: 1, // 至少被引用的次数，满足条件才会代码分割 // maxAsyncRequests: 30, // 按需加载时并行加载的文件的最大数量 // maxInitialRequests: 30, // 入口js文件最大并行请求数量 // enforceSizeThreshold: 50000, // 超过50kb一定会单独打包（此时会忽略minRemainingSize、maxAsyncRequests、maxInitialRequests） // cacheGroups: &#123; // 组，哪些模块要打包到一个组 // defaultVendors: &#123; // 组名 // test: /[\\\\/]node_modules[\\\\/]/, // 需要打包到一起的模块 // priority: -10, // 权重（越大越高） // reuseExistingChunk: true, // 如果当前 chunk 包含已从主 bundle 中拆分出的模块，则它将被重用，而不是生成新的模块 // &#125;, // default: &#123; // 其他没有写的配置会使用上面的默认值 // minChunks: 2, // 这里的minChunks权重更大 // priority: -20, // reuseExistingChunk: true, // &#125;, // &#125;, // 修改配置 cacheGroups: &#123; // 组，哪些模块要打包到一个组 // defaultVendors: &#123; // 组名 // test: /[\\\\/]node_modules[\\\\/]/, // 需要打包到一起的模块 // priority: -10, // 权重（越大越高） // reuseExistingChunk: true, // 如果当前 chunk 包含已从主 bundle 中拆分出的模块，则它将被重用，而不是生成新的模块 // &#125;, default: &#123; // 其他没有写的配置会使用上面的默认值 minSize: 0, // 我们定义的文件体积太小了，所以要改打包的最小文件体积 minChunks: 2, priority: -20, reuseExistingChunk: true, &#125;, &#125;, &#125;, webpack.config.js123456789101112131415161718192021222324252627282930313233343536// Node.js的核心模块，专门用来处理文件路径// 相当于 python osconst path = require(&quot;path&quot;);module.exports = &#123; // 入口 // 相对路径和绝对路径都行 entry: &quot;./src/main.js&quot;, // 输出 output: &#123; // path: 文件输出目录，必须是绝对路径 // path.resolve()方法返回一个绝对路径 // __dirname 当前文件的文件夹绝对路径 path: path.resolve(__dirname, &quot;dist&quot;), // filename: 输出文件名 filename: &quot;main.js&quot;, &#125;, // 加载器 module: &#123; rules: [ &#123; // 文件匹配规则 test: /\\.css$/, // use 处理顺序 从右到左，从左到右 use: [ &quot;style-loader&quot;, &quot;css-loader&quot; ] &#125; ], &#125;, // 插件 plugins: [], // 模式 mode: &quot;&quot;,&#125;;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://example.com/tags/webpack/"},{"name":"打包工具","slug":"打包工具","permalink":"http://example.com/tags/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/"}]}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"毛选","slug":"毛选","permalink":"http://example.com/tags/%E6%AF%9B%E9%80%89/"},{"name":"webpack","slug":"webpack","permalink":"http://example.com/tags/webpack/"},{"name":"打包工具","slug":"打包工具","permalink":"http://example.com/tags/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/"}]}